<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta name="generator" content="Generated by MUP v3.5">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="mup.css">
<title>Non Session Management API</title>
</head>
<body>

<div id=cover>
<h1>Non Session Management API</h1>
<h3></h3>
<address>
Jonathan Moore Liles <a href="mailto:male@tuxfamily.org">&lt;male@tuxfamily.org&gt;</a><br>
<br>
Version 1.2
</address><img src="icon.png" alt="logo"><hr></div>
<div id=body>
<div id=toc>
<h1 id=toc>Table Of Contents</h1>
<ul>
<li><a href="#n:1.">1. Non Session Management API</a>
<ul><li><a href="#n:1.1.">1.1. Client Behavior Under Session Management</a>

<ul><li><a href="#n:1.1.1.">1.1.1. File Menu</a>

<ul><li><a href="#n:1.1.1.1.">1.1.1.1. New</a>

<li><a href="#n:1.1.1.2.">1.1.1.2. Open</a>

<li><a href="#n:1.1.1.3.">1.1.1.3. Save</a>

<li><a href="#n:1.1.1.4.">1.1.1.4. Save As</a>

<li><a href="#n:1.1.1.5.">1.1.1.5. Close (as distinguished from Quit or Exit)</a>

<li><a href="#n:1.1.1.6.">1.1.1.6. Quit or Exit</a>

</ul><li><a href="#n:1.1.2.">1.1.2. Data Storage</a>

<ul><li><a href="#n:1.1.2.1.">1.1.2.1. Internal Files</a>

<li><a href="#n:1.1.2.2.">1.1.2.2. External Files</a>

</ul></ul><li><a href="#n:1.2.">1.2. NSM OSC Protocol</a>

<ul><li><a href="#n:1.2.1.">1.2.1. Establishing a Connection</a>

<ul><li><a href="#n:1.2.1.1.">1.2.1.1. Announce</a>

<li><a href="#n:1.2.1.2.">1.2.1.2. Response</a>

</ul><li><a href="#n:1.2.2.">1.2.2. Server to Client Control Messages</a>

<ul><li><a href="#n:1.2.2.1.">1.2.2.1. Quit</a>

<li><a href="#n:1.2.2.2.">1.2.2.2. Open </a>

<ul><li><a href="#n:1.2.2.2.1.">1.2.2.2.1. Response</a>

</ul><li><a href="#n:1.2.2.3.">1.2.2.3. Save</a>

<ul><li><a href="#n:1.2.2.3.1.">1.2.2.3.1. Response</a>

</ul></ul><li><a href="#n:1.2.3.">1.2.3. Server to Client Informational Messages</a>

<ul><li><a href="#n:1.2.3.1.">1.2.3.1. Session is Loaded</a>

<li><a href="#n:1.2.3.2.">1.2.3.2. Show Optional Gui</a>

</ul><li><a href="#n:1.2.4.">1.2.4. Client to Server Informational Messages</a>

<ul><li><a href="#n:1.2.4.1.">1.2.4.1. Optional GUI</a>

<li><a href="#n:1.2.4.2.">1.2.4.2. Progress</a>

<li><a href="#n:1.2.4.3.">1.2.4.3. Dirtiness</a>

<li><a href="#n:1.2.4.4.">1.2.4.4. Status Messages</a>

</ul><li><a href="#n:1.2.5.">1.2.5. Error Code Definitions</a>

<li><a href="#n:1.2.6.">1.2.6. Client to Server Control</a>

<li><a href="#n:1.2.7.">1.2.7. Server Control API</a>

<ul><li><a href="#n:1.2.7.1.">1.2.7.1. Client to Client Communication</a>

</ul></ul></ul></ul></ul><hr></div>
<h1 id="n:1.">1. Non Session Management API</h1>
<p>
The Non Session Management API is used by the various components of the Non audio production suite to allow any number of independent programs to be managed together as part of a logical session (i.e. a song). Thus, operations such as loading and saving are synchronized.
</p>
<p>
The API comprises a simple Open Sound Control (OSC) based protocol, along with some behavioral guidelines, which can easily be implemented by various applications.
</p>
<p>
The Non project contains an program called <tt>nsmd</tt> which is an implementation of the server side of the NSM API. <tt>nsmd</tt> is controlled by the <tt>non-session-manager</tt> GUI. However, the same server-side API can also be implemented by other session managers (such as LADISH), although consistency and robustness will likely suffer if non-NSM compliant clients are allowed to participate in a session.  The only dependency for client implementations <tt>liblo</tt> (the OSC library), which several Linux audio applications already link to or plan to link to in the future.
</p>
<p>
The aim of this project is to thoroughly define the behavior required of clients. This is an area where other attempts at session management (LASH and JACK-Session) have failed. Often the difficulty with these systems has been not in implementing support for them, but in attempting to interpret the confusing, ambiguous, or ill-conceived API documentation. For these reasons and more all previous attempts at Linux audio session management protocols are considered harmful.
</p>
<p>
You <b>WILL</b> see some unambiguous and emphatic language in this document. For the good of the user, these rules are meant to be followed and are non-negotiable. If an application does not conform to this specification it should be considered broken. Consistency across applications under session management is very important for a good user experience.
</p>
<h2 id="n:1.1.">1.1. Client Behavior Under Session Management</h2>
<p>
Most graphical applications make available to the user a common set of file operations, typically presented under a File or Project menu.
</p>
<p>
These are: New, Open, Save, Save As, Close and Quit or Exit.
</p>
<p>
The following sub-sections describe how these options should behave when the application is part of an NSM session. These rules only apply when session management is active (that is, after the <tt>announce</tt> handshake described in the <a class=int href="#n:1.2.">1.2. NSM OSC Protocol</a> section).   In order to provide a consistent and predictable user experience, it is critically important for applications to adhere to these guidelines.
</p>
<h3 id="n:1.1.1.">1.1.1. File Menu</h3>
<h4 id="n:1.1.1.1.">1.1.1.1. New</h4>
<p>
This option may empty/reset the current file or project (possibly after user confirmation). <b>UNDER NO CIRCUMSTANCES</b> should it allow the user to create a new project/file in another location.
</p>
<h4 id="n:1.1.1.2.">1.1.1.2. Open</h4>
<p>
This option <b>MUST</b> be disabled. 
</p>
<p>
The application may, however, elect to implement an option called 'Import into Session', creates a copy of a file/project which is then saved at the session path provided by NSM.
</p>
<h4 id="n:1.1.1.3.">1.1.1.3. Save</h4>
<p>
This option should behave as normal, saving the current file/project as established by the NSM <tt>open</tt> message.
</p>
<p>
<b>UNDER NO CIRCUMSTANCES</b> should this option present the user with a choice of where to save the file.
</p>
<h4 id="n:1.1.1.4.">1.1.1.4. Save As</h4>
<p>
This option <b>MUST</b> be disabled.
</p>
<p>
The application may, however, elect to implement an option called 'Export from Session', which creates a copy of the current file/project which is then saved in a user-specified location outside of the session path provided by NSM.
</p>
<h4 id="n:1.1.1.5.">1.1.1.5. Close (as distinguished from Quit or Exit)</h4>
<p>
 This option <b>MUST</b> be disabled unless its meaning is to disconnect the application from session management.
</p>
<h4 id="n:1.1.1.6.">1.1.1.6. Quit or Exit</h4>
<p>
This option may behave as normal (possibly asking the user to confirm exiting).
</p>
<h3 id="n:1.1.2.">1.1.2. Data Storage</h3>
<h4 id="n:1.1.2.1.">1.1.2.1. Internal Files</h4>
<p>
All project specific data created by a client <b>MUST</b> be stored in the per-client storage area provided by NSM. This includes all recorded audio and MIDI files, snapshots, etc. Only global configuration items, exports, and renders of the project may be stored elsewhere (wherever the user specifies).
</p>
<h4 id="n:1.1.2.2.">1.1.2.2. External Files</h4>
<p>
Files required by the project but external to it (typically read-only data such as audio samples) <b>SHOULD</b> be referenced by creating a symbolic link within the assigned session area, and then referring to the symlink. This allows sessions to be archived and transported simply (e.g. with "tar -h") by tools that have no knowledge of the project formats of the various clients in the session. The symlinks thus created should, at the very least, be named after the files they refer to (some unique component may be required to prevent collisions)
</p>
<div class="fig example"><table width=100%><tr><td><pre>
samples/drumbeat-1.wav
samples/drumbeat-2.wav
</pre></td></tr>
</table></div>
<h2 id="n:1.2.">1.2. NSM OSC Protocol</h2>
<p>
All message parameters are <b>REQUIRED</b>. All messages <b>MUST</b> be sent from the same socket as the <tt>announce</tt> message, using the <tt>lo_send_from</tt> method of liblo or its equivalent, as the server uses the return addresses to distinguish between clients.
</p>
<p>
Clients <b>MUST</b> create thier OSC servers using the same protocol (UDP,TCP) as found in <tt>NSM_URL</tt>. liblo is lacking a robust TCP implementation at the time of writing, but in the future it may be useful.
</p>
<h3 id="n:1.2.1.">1.2.1. Establishing a Connection</h3>
<h4 id="n:1.2.1.1.">1.2.1.1. Announce</h4>
<p>
At launch, the client <b>MUST</b> check the environment for the value of <tt>NSM_URL</tt>. If present, the client <b>MUST</b> send the following message to the provided address as soon as it is ready to respond to the <tt>/nsm/client/open</tt> event:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/server/announce s:application_name s:capabilities s:executable_name i:api_version_major i:api_version_minor i:pid
</pre></td></tr>
</table></div>
<p>
If <tt>NSM_URL</tt> is undefined, invalid, or unreachable, then the client should proceed assuming that session management is unavailable.
</p>
<p>
<tt>api_version_major</tt> and <tt>api_version_minor</tt> must be the two parts of the version number of the NSM API as defined by this document.
</p>
<p>
Note that if the application intends to register JACK clients, <tt>application_name</tt> <b>MUST</b> be the same as the name that would normally be passed to <tt>jack_client_open</tt>. For example, Non-Mixer sends "Non-Mixer" as its <tt>application_name</tt>. Applications <b>MUST NOT</b> register their JACK clients until receiving an <tt>open</tt> message; the <tt>open</tt> message will provide a unique client name prefix suitable for passing to JACK. This is probably the most complex requirement of the NSM API, but it isn't difficult to implement, especially if the application simply wishes to delay its initialization process breifly while awaiting the <tt>announce</tt> reply and subsequent <tt>open</tt> message.
</p>
<p>
<tt>capabilities</tt> <b>MUST</b> be a string containing a colon separated list of the special capabilities the client possesses. e.g. <tt>:dirty:switch:progress:</tt>
</p>
<p>
<tt>executable_name</tt> <b>MUST</b> be the executable name that the program was launched with. For C programs, this is simply the value of <tt>argv[0]</tt>. Note that hardcoding the name of the program here is not the same as using, as the user may have launched the program from a script with a different name using exec, or have created a symlink to the program. Getting the correct value in scripting languages like Python can be more challenging.
</p>
<center><div class="fig table"><table id="Fig.1.1" border=1>
<caption>
<strong>Fig. 1.1.</strong> Available Client Capabilities
</caption>
<tr><th>Name</th><th>Description</th></tr>
<tr><td>switch</td><td>client is capable of responding to multiple `open` messages without restarting</td></tr>
<tr><td>dirty</td><td>client knows when it has unsaved changes</td></tr>
<tr><td>progress</td><td>client can send progress updates during time-consuming operations</td></tr>
<tr><td>message</td><td>client can send textual status updates </td></tr>
<tr><td>optional-gui</td><td>client has an optional GUI</td></tr>
</table></div></center>
<h4 id="n:1.2.1.2.">1.2.1.2. Response</h4>
<p>
The server will respond to the client's <tt>announce</tt> message with the following message:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/reply "/nsm/server/announce" s:message s:name_of_session_manager s:capabilities
</pre></td></tr>
</table></div>
<p>
<tt>message</tt> is a welcome message.
</p>
<p>
The value of <tt>name_of_session_manager</tt> will depend on the implementation of the NSM server. It might say "Non Session Manager", or it might say "LADISH". This is for display to the user.
</p>
<p>
<tt>capabilities</tt> will be a string containing a colon separated list of special server capabilities.
</p>
<p>
Presently, the server <tt>capabilities</tt> are:
</p>
<center><div class="fig table"><table id="Fig.1.2" border=1>
<caption>
<strong>Fig. 1.2.</strong> Available Server Capabilities
</caption>
<tr><th>Name</th><th>Description</th></tr>
<tr><td>server_control</td><td>client-to-server control</td></tr>
<tr><td>broadcast</td><td>server responds to /nsm/server/broadcast message</td></tr>
<tr><td>optional-gui</td><td>server responds to optional-gui messages--if this capability is not present then clients with optional-guis MUST always keep them visible</td></tr>
</table></div></center>
<p>
A client should not consider itself to be under session management until it receives this response. For example, the Non applications activate their "SM" blinkers at this time.
</p>
<p>
If there is an error, a reply of the following form will be sent to the client:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/error "/nsm/server/announce" i:error_code s:error_message
</pre></td></tr>
</table></div>
<p>
The following table defines possible values of <tt>error_code</tt>:
</p>
<center><div class="fig table"><table id="Fig.1.3" border=1>
<caption>
<strong>Fig. 1.3.</strong> Response codes
</caption>
<tr><th>Code</th><th>Meaning</th></tr>
<tr><td>ERR_GENERAL</td><td>General Error</td></tr>
<tr><td>ERR_INCOMPATIBLE_API</td><td>Incompatible API version</td></tr>
<tr><td>ERR_BLACKLISTED</td><td>Client has been blacklisted.</td></tr>
</table></div></center>
<h3 id="n:1.2.2.">1.2.2. Server to Client Control Messages</h3>
<p>
Compliant clients <b>MUST</b> accept the client control messages described in this section. All client control messages <b>REQUIRE</b> a response. Responses <b>MUST</b> be delivered back to the sender (NSM) from the same socket used by the client in its <tt>announce</tt> message (by using <tt>lo_send_from</tt>) <b>AFTER</b> the action has been completed or if an error is encountered. The required response is described in the subsection for each message.
</p>
<p>
If there is an error and the action cannot be completed, then <tt>error_code</tt> <b>MUST</b> be set to a valid error code (see <a class=int href="#n:1.2.5.">1.2.5. Error Code Definitions</a>) and <tt>message</tt> to a string describing the problem (suitable for display to the user).
</p>
<p>
The reply can take one of the following two forms, where <tt>path</tt> <b>MUST</b> be the path of the message being replied to (e.g. "<i>nsm/client/save"</i>:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/reply s:path s:message
</pre></td></tr>
</table></div>
<div class="fig example"><table width=100%><tr><td><pre>
/error s:path i:error_code s:message
</pre></td></tr>
</table></div>
<h4 id="n:1.2.2.1.">1.2.2.1. Quit</h4>
<p>
There is no message for this. Clients will receive the Unix SIGTERM signal and <b>MUST</b> close cleanly <b>IMMEDIATELY</b>, without displaying any kind of dialog to the user and regardless of whether or not unsaved changes would be lost. When a session is closed the application will receive this signal soon after having responded to a <tt>save</tt> message.
</p>
<h4 id="n:1.2.2.2.">1.2.2.2. Open </h4>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/open s:path_to_instance_specific_project s:display_name s:client_id
</pre></td></tr>
</table></div>
<p>
<tt>path_to_instance_specific_project</tt> is a path name assigned to the client for storing its project data.
</p>
<p>
The client may append to the path, creating a sub-directory, e.g. '/song.foo' or simply append the client's native file extension (e.g. '.non' or '.XML'). The same transformation <b>MUST</b> be applied to the name when opening an existing project, as NSM will only provide the instance specific part of the path.
</p>
<p>
If a project exists at the path, the client <b>MUST</b> immediately open it.
</p>
<p>
If a project does not exist at the path, then the client <b>MUST</b> immediately create and open a new one at the specified path or, for clients which hold all their state in memory, store the path for later use when responding to the <tt>save</tt> message.
</p>
<p>
No file or directory will be created at the specified path by the server. It is up to the client to create what it needs.
</p>
<p>
For clients which <b>HAVE NOT</b> specified the <tt>:switch:</tt> capability, the <tt>open</tt> message will only be delivered once, immediately following the <tt>announce</tt> response.
</p>
<p>
For clients which <b>HAVE</b> specified the <tt>:switch:</tt> capability, the client <b>MUST</b> immediately switch to the specified project or create a new one if it doesn't exist.
</p>
<p>
Clients which are incapable of switching projects or are prone to crashing upon switching <b>MUST NOT</b> include <tt>:switch:</tt> in their capability string.
</p>
<p>
If the user the is allowed to run two or more instances of the application simultaneously (that is to say, there is no technical limitation preventing them from doing so, even if it doesn't make sense to the author), then such an application <b>MUST PRE-PEND</b> the provided <tt>client_id</tt> string to any names it registers with common subsystems (e.g. JACK client names). This ensures that multiple instances of the same application can be restored in any order without scrambling the JACK connections or causing other conflicts. The provided <tt>client_id</tt> will be a concatenation of the value of <tt>application_name</tt> sent by the client in its <tt>announce</tt> message and a unique identifier. Therefore, applications which create single JACK clients can use the value of <tt>client_id</tt> directly as their JACK client name. Applications which register multiple JACK clients (e.g. Non-Mixer) <b>MUST PRE-PEND</b> <tt>client_id</tt> value to the client names they register with JACK and the application determined part <b>MUST</b> be unique for that (JACK) client.
</p>
<p>
For example, a suitable JACK client name would be:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
$CLIENT_ID/track-1
</pre></td></tr>
</table></div>
<p>
Note that this means that the application <b>MUST NOT</b> register with JACK (or any other subsystem requiring unique names) until it receives an <tt>open</tt> message from NSM. Likewise, applications with the <tt>:switch:</tt> capability should close their JACK clients and re-create them with using the new <tt>client_id</tt>. Re-registering is necessary because the JACK API does currently support renaming existing clients, although this is a sorely needed addition.
</p>
<p>
A response is <b>REQUIRED</b> as soon as the open operation has been completed.  Ongoing progress may be indicated by sending messages to <tt>/nsm/client/progress</tt>.
</p>
<h5 id="n:1.2.2.2.1.">1.2.2.2.1. Response</h5>
<p>
The client <b>MUST</b> respond to the 'open' message with:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/reply "/nsm/client/open" s:message
</pre></td></tr>
</table></div>
<p>
Or
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/error "/nsm/client/open" i:error_code s:message
</pre></td></tr>
</table></div>
<center><div class="fig table"><table id="Fig.1.4" border=1>
<caption>
<strong>Fig. 1.4.</strong> Response Codes
</caption>
<tr><th>Code</th><th>Meaning</th></tr>
<tr><td>ERR</td><td>General Error</td></tr>
<tr><td>ERR_BAD_PROJECT</td><td>An existing project file was found to be corrupt</td></tr>
<tr><td>ERR_CREATE_FAILED</td><td>A new project could not be created</td></tr>
<tr><td>ERR_UNSAVED_CHANGES</td><td>Unsaved changes would be lost</td></tr>
<tr><td>ERR_NOT_NOW</td><td>Operation cannot be completed at this time</td></tr>
</table></div></center>
<h4 id="n:1.2.2.3.">1.2.2.3. Save</h4>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/save
</pre></td></tr>
</table></div>
<p>
This message will only be delivered after a previous <tt>open</tt> message, and may be sent any number of times within the course of a session (including zero, if the user aborts the session).
</p>
<p>
<h5 id="n:1.2.2.3.1.">1.2.2.3.1. Response</h5>
<p>
The client <b>MUST</b> respond to the 'save' message with:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/reply "/nsm/client/save" s:message
</pre></td></tr>
</table></div>
<p>
Or
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/error "/nsm/client/save" i:error_code s:message
</pre></td></tr>
</table></div>
<center><div class="fig table"><table id="Fig.1.5" border=1>
<caption>
<strong>Fig. 1.5.</strong> Response Codes
</caption>
<tr><th>Code</th><th>Meaning</th></tr>
<tr><td>ERR</td><td>General Error</td></tr>
<tr><td>ERR_SAVE_FAILED</td><td>Project could not be saved</td></tr>
<tr><td>ERR_NOT_NOW</td><td>Operation cannot be completed at this time</td></tr>
</table></div></center>
<h3 id="n:1.2.3.">1.2.3. Server to Client Informational Messages</h3>
<h4 id="n:1.2.3.1.">1.2.3.1. Session is Loaded</h4>
<p>
 Accepting this message is optional. The intent is to signal to clients which may have some interdependence (say, peer to peer OSC connections) that the session is fully loaded and all their peers are available. Most clients will not need to act on this message. This message has no meaning when a session is being built or run--only when it is initially loaded. Clients who intend to act on this message <b>MUST</b> not do so by delaying initialization waiting for it.
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/session_is_loaded
</pre></td></tr>
</table></div>
<p>
This message does not require a response.
</p>
<h4 id="n:1.2.3.2.">1.2.3.2. Show Optional Gui</h4>
<p>
If the client has specified the <tt>optional-gui</tt> capability, then it may receive this message from the server when the user wishes to change the visibility state of the GUI. It doesn't matter if the optional GUI is integrated with the program or if it is a separate program \(as is the case with SooperLooper\). When the GUI is hidden, there should be no window mapped and if the GUI is a separate program, it should be killed.
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/show_optional_gui 
</pre></td></tr>
</table></div>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/hide_optional_gui
</pre></td></tr>
</table></div>
<p>
No response is message is required.
</p>
<h3 id="n:1.2.4.">1.2.4. Client to Server Informational Messages</h3>
<p>
These are optional messages which a client can send to the NSM server to inform it about the client's status. The client should not expect any reply to these messages. If a client intends to send a message described in this section, then it <b>MUST</b> add the appropriate value to its <tt>capabilities</tt> string when composing the <tt>announce</tt> message.
</p>
<h4 id="n:1.2.4.1.">1.2.4.1. Optional GUI</h4>
<p>
If the client has specified the <tt>optional-gui</tt> capability, then it <b>MUST</b> send this message whenever the state of visibility of the optional GUI has changed. It also <b>MUST</b> send this message after it's announce message to indicate the initial visibility state of the optional GUI.
</p>
<p>
It is the responsibility of the client to remember the visibility state of its GUI across session loads.
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/gui_is_hidden
</pre></td></tr>
</table></div>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/gui_is_shown
</pre></td></tr>
</table></div>
<p>
No response will be delivered.
</p>
<h4 id="n:1.2.4.2.">1.2.4.2. Progress</h4>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/progress f:progress
</pre></td></tr>
</table></div>
<p>
For potentially time-consuming operations, such as <tt>save</tt> and <tt>open</tt>, progress updates may be indicated throughout the duration by sending a floating point value between 0.0 and 1.0, 1.0 indicating completion, to the NSM server.
</p>
<p>
The server will not send a response to these messages, but will relay the information to the user.
</p>
<p>
Note that even when using the <tt>progress</tt> feature, the final response to the <tt>save</tt> or <tt>open</tt> message is still <b>REQUIRED</b>.
</p>
<p>
Clients which intend to send <tt>progress</tt> messages should include <tt>:progress:</tt> in their <tt>announce</tt> capability string.
</p>
<h4 id="n:1.2.4.3.">1.2.4.3. Dirtiness</h4>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/is_dirty
</pre></td></tr>
</table></div>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/is_clean
</pre></td></tr>
</table></div>
<p>
Some clients may be able to inform the server when they have unsaved changes pending. Such clients may optionally send <tt>is_dirty</tt> and <tt>is_clean</tt> messages. 
</p>
<p>
Clients which have this capability should include <tt>:dirty:</tt> in their <tt>announce</tt> capability string.
</p>
<h4 id="n:1.2.4.4.">1.2.4.4. Status Messages</h4>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/client/message i:priority s:message
</pre></td></tr>
</table></div>
<p>
Clients may send miscellaneous status updates to the server for possible display to the user. This may simply be chatter that is normally written to the console. <tt>priority</tt> should be a number from 0 to 3, 3 being the most important.
</p>
<p>
Clients which have this capability should include <tt>:message:</tt> in their <tt>announce</tt> capability string.
</p>
<h3 id="n:1.2.5.">1.2.5. Error Code Definitions</h3>
<center><div class="fig table"><table id="Fig.1.6" border=1>
<caption>
<strong>Fig. 1.6.</strong> Error Code Definitions
</caption>
<tr><th>Symbolic Name</th><th>Integer Value</th></tr>
<tr><td>ERR_GENERAL</td><td>-1</td></tr>
<tr><td>ERR_INCOMPATIBLE_API</td><td>-2</td></tr>
<tr><td>ERR_BLACKLISTED</td><td>-3</td></tr>
<tr><td>ERR_LAUNCH_FAILED</td><td>-4</td></tr>
<tr><td>ERR_NO_SUCH_FILE</td><td>-5</td></tr>
<tr><td>ERR_NO_SESSION_OPEN</td><td>-6</td></tr>
<tr><td>ERR_UNSAVED_CHANGES</td><td>-7</td></tr>
<tr><td>ERR_NOT_NOW</td><td>-8</td></tr>
<tr><td>ERR_BAD_PROJECT</td><td>-9</td></tr>
<tr><td>ERR_CREATE_FAILED</td><td>-10</td></tr>
</table></div></center>
<h3 id="n:1.2.6.">1.2.6. Client to Server Control</h3>
<p>
If the server publishes the <tt>:server_control:</tt> capability, then clients can also initiate action by the server. For example, a client might implement a 'Save All' option which sends a <tt>/nsm/server/save</tt> message to the server, rather than requiring the user to switch to the session management interface to effect the save.
</p>
<h3 id="n:1.2.7.">1.2.7. Server Control API</h3>
<p>
The session manager not only manages clients via OSC, but it is itself controlled via OSC messages. The server responds to the following messages.
</p>
<p>
All of the following messages will be responded to, at the sender's address, with one of the two following messages:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/reply s:path s:message
</pre></td></tr>
</table></div>
<div class="fig example"><table width=100%><tr><td><pre>
/error s:path i:error_code s:message
</pre></td></tr>
</table></div>
<p>
 The first parameter of the reply is the path to the message being replied to. The <tt>/error</tt> reply includes an integer error code (non-zero indicates error). <tt>message</tt> will be a description of the error.
</p>
<p>
The possible errors are:
</p>
<center><div class="fig table"><table id="Fig.1.7" border=1>
<caption>
<strong>Fig. 1.7.</strong> Responses
</caption>
<tr><th>Code</th><th>Meaning</th></tr>
<tr><td>ERR_GENERAL</td><td>General Error</td></tr>
<tr><td>ERR_LAUNCH_FAILED</td><td>Launch failed</td></tr>
<tr><td>ERR_NO_SUCH_FILE</td><td>No such file</td></tr>
<tr><td>ERR_NO_SESSION</td><td>No session is open</td></tr>
<tr><td>ERR_UNSAVED_CHANGES</td><td>Unsaved changes would be lost</td></tr>
</table></div></center>
<dl>
<dt><em>/nsm/server/add s:executable_name</em></dt>
</dl>
<p>
Adds a client to the current session.
</p>
<dl>
<dt><em>/nsm/server/save</em></dt>
</dl>
<p>
Saves the current session.
</p>
<dl>
<dt><em>/nsm/server/open s:project_name</em></dt>
</dl>
<p>
Saves the current session and loads a new session.
</p>
<dl>
<dt><em>/nsm/server/new s:project_name</em></dt>
</dl>
<p>
Saves the current session and creates a new session.
</p>
<dl>
<dt><em>/nsm/server/duplicate s:new_project</em></dt>
</dl>
<p>
Saves and closes the current session, makes a copy, and opens it.
</p>
<dl>
<dt><em>/nsm/server/close</em></dt>
</dl>
<p>
Saves and closes the current session.
</p>
<dl>
<dt><em>/nsm/server/abort</em></dt>
</dl>
<p>
Closes the current session <b>WITHOUT SAVING</b>  
</p>
<dl>
<dt><em>/nsm/server/quit</em></dt>
</dl>
<p>
Saves and closes the current session and terminates the server.
</p>
<dl>
<dt><em>/nsm/server/list </em></dt>
</dl>
<p>
Lists available projects. One <tt>/reply</tt> message will be sent for each existing project.
</p>
<h4 id="n:1.2.7.1.">1.2.7.1. Client to Client Communication</h4>
<p>
If the server includes <tt>:broadcast:</tt> in its capability string, then clients may send broadcast messages to each other through the NSM server.  Clients may send messages to the server at the path <tt>/nsm/server/broadcast</tt>.
</p>
<p>
The format of this message is as follows:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/server/broadcast s:path [arguments...]
</pre></td></tr>
</table></div>
<p>
The message will then be relayed to all clients in the session at the path <tt>path</tt> (with the arguments shifted by one). 
</p>
<p>
For example the message:
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/nsm/server/broadcast /tempomap/update "0,120,4/4:12351234,240,4/4"
</pre></td></tr>
</table></div>
<p>
Would broadcast the following message to all clients in the session (except for the sender), some of which might respond to the message by updating their own tempo maps.
</p>
<div class="fig example"><table width=100%><tr><td><pre>
/tempomap/update "0,120,4/4:12351234,240,4/4"
</pre></td></tr>
</table></div>
<p>
The Non programs use this feature to establish peer to peer OSC communication by symbolic names (client IDs) without having to remember the OSC URLs of peers across sessions.
</p>
</div>
</body>
</html>
